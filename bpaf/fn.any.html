<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Parse a single arbitrary item from a command line"><title>any in bpaf - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bpaf" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../bpaf/index.html">bpaf</a><span class="version">0.9.20</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">any</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#use-any-to-capture-the-remaining-arguments" title="Use `any` to capture the remaining arguments">Use <code>any</code> to capture the remaining arguments</a></li><li><a href="#use-any-to-parse-a-non-standard-flag" title="Use `any` to parse a non standard flag">Use <code>any</code> to parse a non standard flag</a></li><li><a href="#use-any-to-parse-a-non-standard-argument" title="Use `any` to parse a non standard argument">Use <code>any</code> to parse a non standard argument</a></li><li><a href="#see-also" title="See also">See also</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate bpaf</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">bpaf</a></div><h1>Function <span class="fn">any</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/bpaf/lib.rs.html#1457-1475">Source</a> </span></div><pre class="rust item-decl"><code>pub fn any&lt;I, T, F&gt;(metavar: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.str.html">str</a>, check: F) -&gt; <a class="struct" href="params/struct.ParseAny.html" title="struct bpaf::params::ParseAny">ParseAny</a>&lt;T&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a> + 'static,
    F: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt; + 'static,
    &lt;I as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html#associatedtype.Err" title="type core::str::traits::FromStr::Err">Err</a>: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a>,</div></code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Parse a single arbitrary item from a command line</p>
<p><strong><code>any</code> is designed to consume items that don’t fit into the usual <a href="params/struct.NamedArg.html#method.flag" title="method bpaf::params::NamedArg::flag"><code>flag</code></a>
/<a href="params/struct.NamedArg.html#method.switch" title="method bpaf::params::NamedArg::switch"><code>switch</code></a>/<a href="params/struct.NamedArg.html#method.argument" title="method bpaf::params::NamedArg::argument"><code>argument</code></a>/<a href="fn.positional.html" title="fn bpaf::positional"><code>positional</code></a>/
<a href="struct.OptionParser.html#method.command" title="method bpaf::OptionParser::command"><code>command</code></a> classification, in most cases you don’t need to use it</strong></p>
<p>By default, <code>any</code> behaves similarly to <a href="fn.positional.html" title="fn bpaf::positional"><code>positional</code></a> so you should be using it near the
rightmost end of the consumer struct and it will only try to parse the first unconsumed item
on the command line. It is possible to lift this restriction by calling
<a href="params/struct.ParseAny.html#method.anywhere" title="method bpaf::params::ParseAny::anywhere"><code>anywhere</code></a> on the parser.</p>
<p><code>check</code> argument is a function from any type <code>I</code> that implements <code>FromStr</code> to <code>T</code>.
Usually this should be <code>String</code> or <code>OsString</code>, but feel free to experiment. When
running <code>any</code> tries to parse an item on a command line into that <code>I</code> and applies the <code>check</code>
function. If the <code>check</code> succeeds - parser <code>any</code> succeeds and produces <code>T</code>, otherwise it behaves
as if it hasn’t seen it. If <code>any</code> works in <code>anywhere</code> mode - it will try to parse all other
unconsumed items, otherwise, <code>any</code> fails.</p>
<h2 id="use-any-to-capture-the-remaining-arguments"><a class="doc-anchor" href="#use-any-to-capture-the-remaining-arguments">§</a>Use <code>any</code> to capture the remaining arguments</h2>
<p>Normally you would use <a href="fn.positional.html" title="fn bpaf::positional"><code>positional</code></a> with <a href="params/struct.ParsePositional.html#method.strict" title="method bpaf::params::ParsePositional::strict"><code>strict</code></a> annotation for
that, but using any allows you to blur the boundary between arguments for child process and self
process a bit more.</p>
<details><summary>Combinatoric example</summary>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Debug, Clone)]
</span><span class="kw">pub struct </span>Options {
    turbo: bool,
    rest: Vec&lt;OsString&gt;,
}

<span class="kw">pub fn </span>options() -&gt; OptionParser&lt;Options&gt; {
    <span class="kw">let </span>turbo = short(<span class="string">'t'</span>)
        .long(<span class="string">"turbo"</span>)
        .help(<span class="string">"Engage the turbo mode"</span>)
        .switch();
    <span class="kw">let </span>rest = any::&lt;OsString, <span class="kw">_</span>, <span class="kw">_</span>&gt;(<span class="string">"REST"</span>, |x| (x != <span class="string">"--help"</span>).then_some(x))
        .help(<span class="string">"app will pass anything unused to a child process"</span>)
        .many();
    <span class="macro">construct!</span>(Options { turbo, rest }).to_options()
}

<span class="kw">fn </span>main() {
    <span class="macro">println!</span>(<span class="string">"{:?}"</span>, options().run())
}</code></pre></div>
</details>
<details><summary>Derive example</summary>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Debug, Clone, Bpaf)]
#[bpaf(options)]
</span><span class="kw">pub struct </span>Options {
    <span class="attr">#[bpaf(short, long)]
    </span><span class="doccomment">/// Engage the turbo mode
    </span>turbo: bool,
    <span class="attr">#[bpaf(any(<span class="string">"REST"</span>, not_help), many)]
    </span><span class="doccomment">/// app will pass anything unused to a child process
    </span>rest: Vec&lt;OsString&gt;,
}

<span class="kw">fn </span>not_help(s: OsString) -&gt; <span class="prelude-ty">Option</span>&lt;OsString&gt; {
    <span class="kw">if </span>s == <span class="string">"--help" </span>{
        <span class="prelude-val">None
    </span>} <span class="kw">else </span>{
        <span class="prelude-val">Some</span>(s)
    }
}

<span class="kw">fn </span>main() {
    <span class="macro">println!</span>(<span class="string">"{:?}"</span>, options().run())
}</code></pre></div>
</details>
<details><summary>Output</summary>
<p><code>--help</code> keeps working for as long as <code>any</code> captures only intended values - that is it ignores
<code>--help</code> flag specifically</p>
<div class='bpaf-doc'>
$ app --help<br>
<p><b>Usage</b>: <tt><b>app</b></tt> [<tt><b>-t</b></tt>] [<tt><i>REST</i></tt>]...</p><p><div>
<b>Available positional items:</b></div><dl><dt><tt><i>REST</i></tt></dt>
<dd>app will pass anything unused to a child process</dd>
</dl>
</p><p><div>
<b>Available options:</b></div><dl><dt><tt><b>-t</b></tt>, <tt><b>--turbo</b></tt></dt>
<dd>Engage the turbo mode</dd>
<dt><tt><b>-h</b></tt>, <tt><b>--help</b></tt></dt>
<dd>Prints help information</dd>
</dl>
</p>
<style>
div.bpaf-doc {
    padding: 14px;
    background-color:var(--code-block-background-color);
    font-family: "Source Code Pro", monospace;
    margin-bottom: 0.75em;
}
div.bpaf-doc dt { margin-left: 1em; }
div.bpaf-doc dd { margin-left: 3em; }
div.bpaf-doc dl { margin-top: 0; padding-left: 1em; }
div.bpaf-doc  { padding-left: 1em; }
</style>
</div>
<p>You can mix <code>any</code> with regular options, here <a href="params/struct.NamedArg.html#method.switch" title="method bpaf::params::NamedArg::switch"><code>switch</code></a> <code>turbo</code> works because it goes
before <code>rest</code> in the parser declaration</p>
<div class='bpaf-doc'>
$ app --turbo git commit -m "hello world"<br>
Options { turbo: true, rest: ["git", "commit", "-m", "hello world"] }
</div>
<p>“before” in the previous line means in the parser definition, not on the user input, here
<code>--turbo</code> gets consumed by <code>turbo</code> parser even the argument goes</p>
<div class='bpaf-doc'>
$ app git commit -m="hello world" --turbo<br>
Options { turbo: true, rest: ["git", "commit", "-m=hello world"] }
</div>
<div class='bpaf-doc'>
$ app -- git commit -m="hello world" --turbo<br>
Options { turbo: false, rest: ["git", "commit", "-m=hello world", "--turbo"] }
</div>
<div class='bpaf-doc'>
$ app git commit -m="hello world" -- --turbo<br>
Options { turbo: false, rest: ["git", "commit", "-m=hello world", "--turbo"] }
</div>
</details>
<h2 id="use-any-to-parse-a-non-standard-flag"><a class="doc-anchor" href="#use-any-to-parse-a-non-standard-flag">§</a>Use <code>any</code> to parse a non standard flag</h2><details><summary>Combinatoric example</summary>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Debug, Clone)]
</span><span class="kw">pub struct </span>Options {
    turbo: bool,
    backing: bool,
    xinerama: bool,
}

<span class="kw">fn </span>toggle_option(name: <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str, help: <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str) -&gt; <span class="kw">impl </span>Parser&lt;bool&gt; {
    <span class="comment">// parse +name and -name into a bool
    </span>any::&lt;String, <span class="kw">_</span>, <span class="kw">_</span>&gt;(name, <span class="kw">move </span>|s: String| {
        <span class="kw">if let </span><span class="prelude-val">Some</span>(rest) = s.strip_prefix(<span class="string">'+'</span>) {
            (rest == name).then_some(<span class="bool-val">true</span>)
        } <span class="kw">else if let </span><span class="prelude-val">Some</span>(rest) = s.strip_prefix(<span class="string">'-'</span>) {
            (rest == name).then_some(<span class="bool-val">false</span>)
        } <span class="kw">else </span>{
            <span class="prelude-val">None
        </span>}
    })
    <span class="comment">// set a custom usage and help metavariable
    </span>.metavar(
        <span class="kw-2">&amp;</span>[
            (<span class="string">"+"</span>, Style::Literal),
            (name, Style::Literal),
            (<span class="string">" | "</span>, Style::Text),
            (<span class="string">"-"</span>, Style::Literal),
            (name, Style::Literal),
        ][..],
    )
    <span class="comment">// set a custom help description
    </span>.help(help)
    <span class="comment">// apply this parser to all unconsumed items
    </span>.anywhere()
}

<span class="kw">pub fn </span>options() -&gt; OptionParser&lt;Options&gt; {
    <span class="kw">let </span>backing = toggle_option(<span class="string">"backing"</span>, <span class="string">"Enable or disable backing"</span>)
        .fallback(<span class="bool-val">false</span>)
        .debug_fallback();
    <span class="kw">let </span>xinerama = toggle_option(<span class="string">"xinerama"</span>, <span class="string">"enable or disable Xinerama"</span>)
        .fallback(<span class="bool-val">true</span>)
        .debug_fallback();
    <span class="kw">let </span>turbo = short(<span class="string">'t'</span>)
        .long(<span class="string">"turbo"</span>)
        .help(<span class="string">"Engage the turbo mode"</span>)
        .switch();
    <span class="macro">construct!</span>(Options {
        turbo,
        backing,
        xinerama,
    })
    .to_options()
}

<span class="kw">fn </span>main() {
    <span class="macro">println!</span>(<span class="string">"{:?}"</span>, options().run())
}</code></pre></div>
</details>
<details><summary>Derive example</summary>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Debug, Clone, Bpaf)]
#[bpaf(options)]
</span><span class="kw">pub struct </span>Options {
    <span class="doccomment">/// Engage the turbo mode
    </span><span class="attr">#[bpaf(short, long)]
    </span>turbo: bool,
    <span class="attr">#[bpaf(external(backing), fallback(<span class="bool-val">false</span>), debug_fallback)]
    </span>backing: bool,
    <span class="attr">#[bpaf(external(xinerama), fallback(<span class="bool-val">true</span>), debug_fallback)]
    </span>xinerama: bool,
}

<span class="kw">fn </span>toggle_option(name: <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str, help: <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str) -&gt; <span class="kw">impl </span>Parser&lt;bool&gt; {
    <span class="comment">// parse +name and -name into a bool
    </span>any::&lt;String, <span class="kw">_</span>, <span class="kw">_</span>&gt;(name, <span class="kw">move </span>|s: String| {
        <span class="kw">if let </span><span class="prelude-val">Some</span>(rest) = s.strip_prefix(<span class="string">'+'</span>) {
            (rest == name).then_some(<span class="bool-val">true</span>)
        } <span class="kw">else if let </span><span class="prelude-val">Some</span>(rest) = s.strip_prefix(<span class="string">'-'</span>) {
            (rest == name).then_some(<span class="bool-val">false</span>)
        } <span class="kw">else </span>{
            <span class="prelude-val">None
        </span>}
    })
    <span class="comment">// set a custom usage and help metavariable
    </span>.metavar(
        <span class="kw-2">&amp;</span>[
            (<span class="string">"+"</span>, Style::Literal),
            (name, Style::Literal),
            (<span class="string">" | "</span>, Style::Text),
            (<span class="string">"-"</span>, Style::Literal),
            (name, Style::Literal),
        ][..],
    )
    <span class="comment">// set a custom help description
    </span>.help(help)
    <span class="comment">// apply this parser to all unconsumed items
    </span>.anywhere()
}

<span class="kw">fn </span>backing() -&gt; <span class="kw">impl </span>Parser&lt;bool&gt; {
    toggle_option(<span class="string">"backing"</span>, <span class="string">"Enable or disable backing"</span>)
}

<span class="kw">fn </span>xinerama() -&gt; <span class="kw">impl </span>Parser&lt;bool&gt; {
    toggle_option(<span class="string">"xinerama"</span>, <span class="string">"enable or disable Xinerama"</span>)
}

<span class="kw">fn </span>main() {
    <span class="macro">println!</span>(<span class="string">"{:?}"</span>, options().run())
}</code></pre></div>
</details>
<details><summary>Output</summary>
<p><code>--help</code> message describes all the flags as expected</p>
<div class='bpaf-doc'>
$ app --help<br>
<p><b>Usage</b>: <tt><b>app</b></tt> [<tt><b>-t</b></tt>] [<tt><b>+backing</b></tt> | <tt><b>-backing</b></tt>] [<tt><b>+xinerama</b></tt> | <tt><b>-xinerama</b></tt>]</p><p><div>
<b>Available options:</b></div><dl><dt><tt><b>-t</b></tt>, <tt><b>--turbo</b></tt></dt>
<dd>Engage the turbo mode</dd>
<dt><tt><b>+backing</b></tt> | <tt><b>-backing</b></tt></dt>
<dd>Enable or disable backing</dd>
<dt></dt>
<dd>[default: false]</dd>
<dt><tt><b>+xinerama</b></tt> | <tt><b>-xinerama</b></tt></dt>
<dd>enable or disable Xinerama</dd>
<dt></dt>
<dd>[default: true]</dd>
<dt><tt><b>-h</b></tt>, <tt><b>--help</b></tt></dt>
<dd>Prints help information</dd>
</dl>
</p>
<style>
div.bpaf-doc {
    padding: 14px;
    background-color:var(--code-block-background-color);
    font-family: "Source Code Pro", monospace;
    margin-bottom: 0.75em;
}
div.bpaf-doc dt { margin-left: 1em; }
div.bpaf-doc dd { margin-left: 3em; }
div.bpaf-doc dl { margin-top: 0; padding-left: 1em; }
div.bpaf-doc  { padding-left: 1em; }
</style>
</div>
<p>Parser obeys the defaults</p>
<div class='bpaf-doc'>
$ app <br>
Options { turbo: false, backing: false, xinerama: true }
</div>
<p>And can handle custom values</p>
<div class='bpaf-doc'>
$ app --turbo -xinerama +backing<br>
Options { turbo: true, backing: true, xinerama: false }
</div>
<p><code>bpaf</code> won’t be able to generate good error messages or suggest to fix typos to users since it
doesn’t really knows what the function inside <code>any</code> is going to consume</p>
<div class='bpaf-doc'>
$ app --turbo -xinerama +backin<br>
<b>Error:</b> <b>+backin</b> is not expected in this context
<style>
div.bpaf-doc {
    padding: 14px;
    background-color:var(--code-block-background-color);
    font-family: "Source Code Pro", monospace;
    margin-bottom: 0.75em;
}
div.bpaf-doc dt { margin-left: 1em; }
div.bpaf-doc dd { margin-left: 3em; }
div.bpaf-doc dl { margin-top: 0; padding-left: 1em; }
div.bpaf-doc  { padding-left: 1em; }
</style>
</div>
</details>
<h2 id="use-any-to-parse-a-non-standard-argument"><a class="doc-anchor" href="#use-any-to-parse-a-non-standard-argument">§</a>Use <code>any</code> to parse a non standard argument</h2>
<p>Normally <code>any</code> would try to display itself as a usual metavariable in the usage line and
generated help, you can customize that with <a href="params/struct.ParseAny.html#method.metavar" title="method bpaf::params::ParseAny::metavar"><code>metavar</code></a> method:</p>
<details><summary>Combinatoric example</summary>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Debug, Clone)]
</span><span class="kw">pub struct </span>Options {
    block_size: usize,
    count: usize,
    output_file: String,
    turbo: bool,
}

<span class="doccomment">/// Parses a string that starts with `name`, returns the suffix parsed in a usual way
</span><span class="kw">fn </span>tag&lt;T&gt;(name: <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str, meta: <span class="kw-2">&amp;</span>str, help: <span class="kw">impl </span>Into&lt;Doc&gt;) -&gt; <span class="kw">impl </span>Parser&lt;T&gt;
<span class="kw">where
    </span>T: FromStr,
    &lt;T <span class="kw">as </span>FromStr&gt;::Err: std::fmt::Display,
{
    <span class="comment">// closure inside checks if command line argument starts with a given name
    // and if it is - it accepts it, otherwise it behaves like it never saw it
    // it is possible to parse OsString here and strip the prefix with
    // `os_str_bytes` or a similar crate
    </span>any(<span class="string">""</span>, <span class="kw">move </span>|s: String| <span class="prelude-val">Some</span>(s.strip_prefix(name)<span class="question-mark">?</span>.to_owned()))
        <span class="comment">// this defines custom metavar for the help message
        // so it looks like something it designed to parse
        </span>.metavar(<span class="kw-2">&amp;</span>[(name, Style::Literal), (meta, Style::Metavar)][..])
        .help(help)
        <span class="comment">// this makes it so tag parser tries to read all (unconsumed by earlier parsers)
        // item on a command line instead of trying and failing on the first one
        </span>.anywhere()
        <span class="comment">// At this point parser produces `String` while consumer might expect some other
        // type. [`parse`](Parser::parse) handles that
        </span>.parse(|s| s.parse())
}

<span class="kw">pub fn </span>options() -&gt; OptionParser&lt;Options&gt; {
    <span class="kw">let </span>block_size = tag(<span class="string">"bs="</span>, <span class="string">"BLOCK"</span>, <span class="string">"How many bytes to read at once"</span>)
        .fallback(<span class="number">1024</span>)
        .display_fallback();
    <span class="kw">let </span>count = tag(<span class="string">"count="</span>, <span class="string">"NUM"</span>, <span class="string">"How many blocks to read"</span>).fallback(<span class="number">1</span>);
    <span class="kw">let </span>output_file = tag(<span class="string">"of="</span>, <span class="string">"FILE"</span>, <span class="string">"Save results into this file"</span>);

    <span class="comment">// this consumes literal value of "+turbo" locate and produces `bool`
    </span><span class="kw">let </span>turbo = literal(<span class="string">"+turbo"</span>)
        .help(<span class="string">"Engage turbo mode!"</span>)
        .anywhere()
        .map(|<span class="kw">_</span>| <span class="bool-val">true</span>)
        .fallback(<span class="bool-val">false</span>);

    <span class="macro">construct!</span>(Options {
        block_size,
        count,
        output_file,
        turbo
    })
    .to_options()
}

<span class="kw">fn </span>main() {
    <span class="macro">println!</span>(<span class="string">"{:?}"</span>, options().run())
}</code></pre></div>
</details>
<details><summary>Derive example</summary>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// This example is still technically derive API, but derive is limited to gluing
// things together and keeping macro complexity under control.
</span><span class="attr">#[derive(Debug, Clone, Bpaf)]
#[bpaf(options)]
</span><span class="kw">pub struct </span>Options {
    <span class="comment">// `external` here and below derives name from the field name, looking for
    // functions called `block_size`, `count`, etc that produce parsers of
    // the right type.
    // A different way would be to write down the name explicitly:
    // #[bpaf(external(block_size), fallback(1024), display_fallback)]
    </span><span class="attr">#[bpaf(external, fallback(<span class="number">1024</span>), display_fallback)]
    </span>block_size: usize,
    <span class="attr">#[bpaf(external, fallback(<span class="number">1</span>))]
    </span>count: usize,
    <span class="attr">#[bpaf(external)]
    </span>output_file: String,
    <span class="attr">#[bpaf(external)]
    </span>turbo: bool,
}

<span class="kw">fn </span>block_size() -&gt; <span class="kw">impl </span>Parser&lt;usize&gt; {
    tag(<span class="string">"bs="</span>, <span class="string">"BLOCK"</span>, <span class="string">"How many bytes to read at once"</span>)
}

<span class="kw">fn </span>count() -&gt; <span class="kw">impl </span>Parser&lt;usize&gt; {
    tag(<span class="string">"count="</span>, <span class="string">"NUM"</span>, <span class="string">"How many blocks to read"</span>)
}

<span class="kw">fn </span>output_file() -&gt; <span class="kw">impl </span>Parser&lt;String&gt; {
    tag(<span class="string">"of="</span>, <span class="string">"FILE"</span>, <span class="string">"Save results into this file"</span>)
}

<span class="kw">fn </span>turbo() -&gt; <span class="kw">impl </span>Parser&lt;bool&gt; {
    literal(<span class="string">"+turbo"</span>)
        .help(<span class="string">"Engage turbo mode!"</span>)
        .anywhere()
        .map(|<span class="kw">_</span>| <span class="bool-val">true</span>)
        .fallback(<span class="bool-val">false</span>)
}

<span class="doccomment">/// Parses a string that starts with `name`, returns the suffix parsed in a usual way
</span><span class="kw">fn </span>tag&lt;T&gt;(name: <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str, meta: <span class="kw-2">&amp;</span>str, help: <span class="kw">impl </span>Into&lt;Doc&gt;) -&gt; <span class="kw">impl </span>Parser&lt;T&gt;
<span class="kw">where
    </span>T: FromStr,
    &lt;T <span class="kw">as </span>FromStr&gt;::Err: std::fmt::Display,
{
    <span class="comment">// closure inside checks if command line argument starts with a given name
    // and if it is - it accepts it, otherwise it behaves like it never saw it
    // it is possible to parse OsString here and strip the prefix with
    // `os_str_bytes` or a similar crate
    </span>any(<span class="string">""</span>, <span class="kw">move </span>|s: String| <span class="prelude-val">Some</span>(s.strip_prefix(name)<span class="question-mark">?</span>.to_owned()))
        <span class="comment">// this defines custom metavar for the help message
        // so it looks like something it designed to parse
        </span>.metavar(<span class="kw-2">&amp;</span>[(name, Style::Literal), (meta, Style::Metavar)][..])
        .help(help)
        <span class="comment">// this makes it so tag parser tries to read all (unconsumed by earlier parsers)
        // item on a command line instead of trying and failing on the first one
        </span>.anywhere()
        <span class="comment">// At this point parser produces `String` while consumer might expect some other
        // type. [`parse`](Parser::parse) handles that
        </span>.parse(|s| s.parse())
}

<span class="kw">fn </span>main() {
    <span class="macro">println!</span>(<span class="string">"{:?}"</span>, options().run())
}</code></pre></div>
</details>
<details><summary>Output</summary>
<p>Instead of usual metavariable <code>any</code> parsers take something that can represent any value</p>
<div class='bpaf-doc'>
$ app --help<br>
<p><b>Usage</b>: <tt><b>app</b></tt> [<tt><b>bs=</b></tt><tt><i>BLOCK</i></tt>] [<tt><b>count=</b></tt><tt><i>NUM</i></tt>] <tt><b>of=</b></tt><tt><i>FILE</i></tt> [<tt><b>+turbo</b></tt>]</p><p><div>
<b>Available options:</b></div><dl><dt><tt><b>bs=</b></tt><tt><i>BLOCK</i></tt></dt>
<dd>How many bytes to read at once</dd>
<dt></dt>
<dd>[default: 1024]</dd>
<dt><tt><b>count=</b></tt><tt><i>NUM</i></tt></dt>
<dd>How many blocks to read</dd>
<dt><tt><b>of=</b></tt><tt><i>FILE</i></tt></dt>
<dd>Save results into this file</dd>
<dt><tt><b>+turbo</b></tt></dt>
<dd>Engage turbo mode!</dd>
<dt><tt><b>-h</b></tt>, <tt><b>--help</b></tt></dt>
<dd>Prints help information</dd>
</dl>
</p>
<style>
div.bpaf-doc {
    padding: 14px;
    background-color:var(--code-block-background-color);
    font-family: "Source Code Pro", monospace;
    margin-bottom: 0.75em;
}
div.bpaf-doc dt { margin-left: 1em; }
div.bpaf-doc dd { margin-left: 3em; }
div.bpaf-doc dl { margin-top: 0; padding-left: 1em; }
div.bpaf-doc  { padding-left: 1em; }
</style>
</div>
<p>Output file is required in this parser, other values are optional</p>
<div class='bpaf-doc'>
$ app <br>
<b>Error:</b> expected <tt><b>of=</b></tt><tt><i>FILE</i></tt>, pass <tt><b>--help</b></tt> for usage information
<style>
div.bpaf-doc {
    padding: 14px;
    background-color:var(--code-block-background-color);
    font-family: "Source Code Pro", monospace;
    margin-bottom: 0.75em;
}
div.bpaf-doc dt { margin-left: 1em; }
div.bpaf-doc dd { margin-left: 3em; }
div.bpaf-doc dl { margin-top: 0; padding-left: 1em; }
div.bpaf-doc  { padding-left: 1em; }
</style>
</div>
<div class='bpaf-doc'>
$ app of=simple.txt<br>
Options { block_size: 1024, count: 1, output_file: "simple.txt", turbo: false }
</div>
<p>Since options are defined with <code>anywhere</code> - order doesn’t matter</p>
<div class='bpaf-doc'>
$ app bs=10 of=output.rs +turbo<br>
Options { block_size: 10, count: 1, output_file: "output.rs", turbo: true }
</div>
<div class='bpaf-doc'>
$ app +turbo bs=10 of=output.rs<br>
Options { block_size: 10, count: 1, output_file: "output.rs", turbo: true }
</div>
<div class='bpaf-doc'>
$ app bs=65536 count=12 of=hello_world.rs<br>
Options { block_size: 65536, count: 12, output_file: "hello_world.rs", turbo: false }
</div>
</details>
<h2 id="see-also"><a class="doc-anchor" href="#see-also">§</a>See also</h2>
<p><a href="fn.literal.html" title="fn bpaf::literal"><code>literal</code></a> - a specialized version of <code>any</code> that tries to parse a fixed literal</p>
</div></details></section></div></main></body></html>